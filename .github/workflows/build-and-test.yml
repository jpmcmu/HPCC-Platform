name: Docker Build & Regression Test
on:
  push:
    branches:
      - "HPCC-29854"
  pull_request:
    branches:
      - "master"
      - "candidate-*.x"
      - "!candidate-8.2.*"
      - "!candidate-8.0.*"
      - "!candidate-7.12.*"
      - "!candidate-7.10.*"
      - "!candidate-7.8.*"
      - "!candidate-7.6.*"
      - "!candidate-7.4.*"
      - "!candidate-7.2.*"
      - "!candidate-7.0.*"
      - "!candidate-6.*"

jobs:
  preamble:
    name: Preamble
    runs-on: ubuntu-22.04
    permissions:
      contents: write
    outputs:
      folder_platform: ${{ steps.vars.outputs.folder_platform }}
      mount_platform: ${{ steps.vars.outputs.mount_platform }}
      folder_ln: ${{ steps.vars.outputs.folder_ln }}
      mount_ln: ${{ steps.vars.outputs.mount_ln }}
      folder_build: ${{ steps.vars.outputs.folder_build }}
      mount_build: ${{ steps.vars.outputs.mount_build }}
      community_ref: ${{ steps.vars.outputs.community_ref }}
      internal_ref: ${{ steps.vars.outputs.internal_ref }}
      community_tag: ${{ steps.vars.outputs.community_tag }}
      internal_tag: ${{ steps.vars.outputs.internal_tag }}
      hpcc_version: ${{ steps.vars.outputs.hpcc_version }}
      candidate_base_branch: ${{ steps.vars.outputs.candidate_base_branch }}
      candidate_branch: ${{ steps.vars.outputs.candidate_branch }}
      cmake_docker_config: ${{ steps.vars.outputs.cmake_docker_config }}
      gpg_import: ${{ steps.vars.outputs.gpg_import }}
    steps:
      - name: Calculate vars
        id: vars
        run: |
          echo "folder_platform=${{ github.workspace }}/HPCC-Platform" >> $GITHUB_OUTPUT
          echo 'mount_platform=source="${{ github.workspace }}/HPCC-Platform",target=/hpcc-dev/HPCC-Platform,type=bind,consistency=cached' >> $GITHUB_OUTPUT
          echo "folder_ln=${{ github.workspace }}/LN" >> $GITHUB_OUTPUT
          echo 'mount_ln=source="${{ github.workspace }}/LN",target=/hpcc-dev/LN,type=bind,consistency=cached' >> $GITHUB_OUTPUT
          echo "folder_build=${{ github.workspace }}/build" >> $GITHUB_OUTPUT
          echo 'mount_build=source="${{ github.workspace }}/build",target=/hpcc-dev/build,type=bind,consistency=cached' >> $GITHUB_OUTPUT
          community_ref=${{ github.ref }}
          echo "community_ref=$community_ref" >> $GITHUB_OUTPUT
          echo "internal_ref=$(echo $community_ref | sed 's/community/internal/')" >> $GITHUB_OUTPUT
          community_tag=$(echo $community_ref | cut -d'/' -f3)
          echo "community_tag=$community_tag" >> $GITHUB_OUTPUT
          echo "internal_tag=$(echo $community_tag | sed 's/community/internal/')" >> $GITHUB_OUTPUT
          echo "hpcc_version=$(echo $community_tag | sed 's/community_//' | sed 's/-[0-9]$//')" >> $GITHUB_OUTPUT
          community_base_ref=${{ github.event.base_ref || github.ref }}
          candidate_branch=$(echo $community_base_ref | cut -d'/' -f3)
          echo "candidate_branch=$candidate_branch" >> $GITHUB_OUTPUT
          echo "candidate_base_branch=$(echo $candidate_branch | awk -F'.' -v OFS='.' '{ $3="x"; print }')" >> $GITHUB_OUTPUT
          echo "cmake_docker_config=-DCMAKE_BUILD_TYPE=RelWithDebInfo -DVCPKG_FILES_DIR=/hpcc-dev -DCPACK_THREADS=0 -DUSE_OPTIONAL=OFF -DSIGN_MODULES=${{ github.repository_owner == 'hpcc-systems' && 'ON' || 'OFF' }}" >> $GITHUB_OUTPUT
          echo 'gpg_import=gpg --batch --import /hpcc-dev/build/private.key' >> $GITHUB_OUTPUT

      - name: Print vars
        run: |
          echo "${{ toJSON(steps.vars.outputs) }})"

  build-and-test:
    name: Build Platform & HPCC4j Tests
    needs: preamble
    runs-on: ubuntu-22.04
    env:
      os: ubuntu-22.04
    steps:
      - name: Checkout PR
        uses: actions/checkout@v3
        with:
          submodules: recursive
          path: ./HPCC-Platform

      - name: "vcpkg Bootstrap"
        shell: "bash"
        run: |
          ./HPCC-Platform/vcpkg/bootstrap-vcpkg.sh

      - name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: |
            network=host

      - name: Calculate vars
        id: vars
        working-directory: ${{ needs.preamble.outputs.folder_platform }}/vcpkg
        run: |
          vcpkg_sha_short=$(git rev-parse --short=8 HEAD)
          echo "vcpkg_sha_short=$vcpkg_sha_short" >> $GITHUB_OUTPUT
          docker_build_label=hpccsystems/platform-build-${{ env.os }}
          echo "docker_build_label=$docker_build_label" >> $GITHUB_OUTPUT
          echo "docker_tag=$docker_build_label:$vcpkg_sha_short" >> $GITHUB_OUTPUT
          echo "docker_tag_candidate_base=$docker_build_label:${{ needs.preamble.outputs.candidate_base_branch }}" >> $GITHUB_OUTPUT

      - name: Create Build Image
        uses: docker/build-push-action@v4
        with:
          builder: ${{ steps.buildx.outputs.name }}
          file: ${{ needs.preamble.outputs.folder_platform }}/dockerfiles/vcpkg/${{ env.os }}.dockerfile
          context: ${{ needs.preamble.outputs.folder_platform }}/dockerfiles/vcpkg
          push: ${{ github.repository_owner == 'hpcc-systems' }}
          load: ${{ github.repository_owner != 'hpcc-systems' }}
          build-args: |
            VCPKG_REF=${{ steps.vars.outputs.vcpkg_sha_short }}
          tags: |
            ${{ steps.vars.outputs.docker_tag_candidate_base }}
          cache-from: |
            type=registry,ref=${{ steps.vars.outputs.docker_tag_candidate_base }}
            type=registry,ref=${{ steps.vars.outputs.docker_tag }}
          cache-to: type=inline

      - name: CMake Containerized Packages (community)
        run: |
          mkdir -p ${{ needs.preamble.outputs.folder_build }}
          echo "${{ secrets.SIGNING_SECRET }}" > ${{ needs.preamble.outputs.folder_build }}/private.key
          sudo rm -f ${{ needs.preamble.outputs.folder_build }}/CMakeCache.txt
          sudo rm -rf ${{ needs.preamble.outputs.folder_build }}/CMakeFiles
          docker run --rm --mount ${{ needs.preamble.outputs.mount_platform }} --mount ${{ needs.preamble.outputs.mount_build }} ${{ steps.vars.outputs.docker_tag_candidate_base }} "${{ needs.preamble.outputs.gpg_import }} && \
            cmake -S /hpcc-dev/HPCC-Platform -B /hpcc-dev/build ${{ needs.preamble.outputs.cmake_docker_config }} -DSIGN_MODULES_PASSPHRASE=${{ secrets.SIGN_MODULES_PASSPHRASE }} -DSIGN_MODULES_KEYID=${{ secrets.SIGN_MODULES_KEYID }} -DINCLUDE_PLUGINS=ON -DCONTAINERIZED=ON -DSUPPRESS_REMBED=ON -DSUPPRESS_V8EMBED=ON -DSUPPRESS_SPARK=ON -DCPACK_STRIP_FILES=ON ${{ matrix.cmake_options_extra }} && \
            cmake --build /hpcc-dev/build --parallel $(nproc) --target package"
          mkdir temp
          sudo mv ${{ needs.preamble.outputs.folder_build }}/*.deb temp/
          sudo rm -rf ${{ needs.preamble.outputs.folder_build }}/*
          sudo mv temp/* ${{ needs.preamble.outputs.folder_build }}/
          sudo rmdir temp

      - name: Install K8s
        uses: balchua/microk8s-actions@v0.3.2
        with:
          channel: '1.26/stable'
          devMode: 'true'
          addons: '["dns", "rbac", "hostpath-storage", "registry"]'

      - name: Create Docker Image (community)
        uses: docker/build-push-action@v4
        with:
          builder: ${{ steps.buildx.outputs.name }}
          file: ${{ needs.preamble.outputs.folder_platform }}/dockerfiles/vcpkg/${{ env.os }}.dockerfile
          context: ${{ needs.preamble.outputs.folder_build }}
          push: true
          outputs: type=docker,dest=/tmp/hpcc_latest.tar
          build-args: |
            PKG_FILE=${{ steps.container.outputs.k8s_pkg_file }}
          tags: localhost:5000/hpcc:local_latest
          cache-from: |
            type=registry,ref=hpccsystems/platform-core-${{ env.os }}:${{ needs.preamble.outputs.candidate_base_branch }}

      # Note: IP Address range below is the IP address range that will be made available for load balancers
      # on the host machine, they aren't actual load balancers so they will not be accessible externally
      - name: Enable LoadBalancers
        run: |
          sudo microk8s enable metallb:10.64.140.43-10.64.140.69

      - name: Create Root Certificates
        run: |
          echo "[req]
          default_bits           = 2048
          default_keyfile        = ca.key
          distinguished_name     = dn
          prompt                 = no
          x509_extensions        = x509_ca

          [dn]
          C                      = US
          ST                     = GA
          L                      = Alparetta
          O                      = Lexis Nexis Risk
          OU                     = Platform Development
          CN                     = TestCluster
          emailAddress           = support@lexisnexisrisk.com

          [x509_ca]
          basicConstraints=CA:true,pathlen:1" > ca-req.cfg
          openssl req -x509 -newkey rsa:2048 -nodes -keyout ca.key -sha256 -days 1825 -out ca.crt -config ca-req.cfg
          kubectl create secret tls hpcc-signing-issuer-key-pair --cert=ca.crt --key=ca.key
          kubectl create secret tls hpcc-local-issuer-key-pair --cert=ca.crt --key=ca.key
          sudo keytool -import -trustcacerts -cacerts -storepass changeit -noprompt -alias hpcc-local-issuer -file ca.crt

      - name: Install JetStack Cert Manager
        run: |
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.11.0/cert-manager.crds.yaml
          helm install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --version v1.11.0

      - name: Install HPCC Cluster
        run: |
          echo -e "certificates:\n  enabled: true\ndafilesrv:\n  - name: rowservice\n    disabled: false\n    application: stream\n    service:\n      servicePort: 7600\n      visibility: global" > values.yaml
          helm repo add hpcc https://hpcc-systems.github.io/helm-chart
          helm repo update
          helm install myhpcc ${{ needs.preamble.outputs.folder_platform }}/helm/hpcc --set global.image.version=local_latest -f values.yaml
          sleep 10

      - name: Wait for ECLWatch Startup
        run: |
          kubectl get pods
          echo "Waiting for ECLWatch startup" && kubectl wait --for=condition=ready pod --timeout=180s -l app=eclwatch
          echo "Waiting for Rowservice startup" && kubectl wait --for=condition=ready pod --timeout=180s -l server=rowservice
          echo "Waiting for SQL2ECL startup" && kubectl wait --for=condition=ready pod --timeout=180s -l app=sql2ecl
          echo "ECLWATCH_IP=$(kubectl get svc eclwatch -o jsonpath='{.spec.clusterIP}')" >> $GITHUB_ENV
          echo "ROWSERVICE_IP=$(kubectl get svc rowservice -o jsonpath='{.spec.clusterIP}')" >> $GITHUB_ENV
          echo "SQL_TO_ECL_IP=$(kubectl get svc sql2ecl -o jsonpath='{.spec.clusterIP}')" >> $GITHUB_ENV
          kubectl get pods
          kubectl get svc
          kubectl get deployments -o wide

      - name: Add Host File Entries
        run: |
          sudo -- sh -c -e "echo '${{ env.ECLWATCH_IP }} eclwatch.default' >> /etc/hosts";
          sudo -- sh -c -e "echo '${{ env.ROWSERVICE_IP }} rowservice.default' >> /etc/hosts";
          sudo -- sh -c -e "echo '${{ env.SQL_TO_ECL_IP }} sql2ecl.default' >> /etc/hosts";

      - name: Trust Certs
        run: |
          openssl s_client -showcerts -connect eclwatch.default:8010 < /dev/null | openssl x509 -outform DER > cert.der
          sudo keytool -import -keystore $JAVA_HOME/lib/security/cacerts -storepass changeit -noprompt -alias eclwatch-tls -file cert.der
          openssl s_client -showcerts -connect rowservice.default:7600 < /dev/null | openssl x509 -outform DER > cert.der
          sudo keytool -import -keystore $JAVA_HOME/lib/security/cacerts -storepass changeit -noprompt -alias dafilesrv-tls -file cert.der
          openssl s_client -showcerts -connect sql2ecl.default:8510 < /dev/null | openssl x509 -outform DER > cert.der
          sudo keytool -import -keystore $JAVA_HOME/lib/security/cacerts -storepass changeit -noprompt -alias sqltoecl-tls -file cert.der




